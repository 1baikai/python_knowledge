回顾
  in / not in
  列表的索引
     列表支持索引赋值
  列表的切片
    列表的切片赋值可以实现,替换,添加,删除列表中的元素

  删除列表中的元素
    del 列表[索引]
    del 列表[切片]
    列表.pop([索引])
    列表.remomve(对象)

  列表的方法:
    L.clear()
    L.append()
    L.extend()
    L.clear()
    L.remove()
    L.pop()
    L.insert()
  用于列表的函数:
    len(x), max(x), min(x), sum(x), any(x), all(x)

深拷贝和浅拷贝
    L1 = [1, 2, [3, 4,[5,6]]]

    L2 = L1  # 不拷贝
    L3 =　L1.copy()  # L3 = L1[:]　　浅拷贝
    import copy
    L4 = copy.deepcopy(L1)

字符串的两个方法
   S.split
   S.join
   
列表推导式:
   L = [5, 4, 7, 2, 1]
   L2 = [str(x**2) for x in L]
　　　s = '+'.join(L2)  # s = '25+16+49+4+1'




今日小菜鸟的笔记:
元组 tuple
  元组是不可改变的序列，同list一样，元组可以存放任意类型的元素
  元组一但创建将不可改变

元组的表示方式:
  用小括号() 括起来，单个元素括起来后加逗号(,)区分单个对象还是元组

创建空元组的字面值表达式
  t = ()  # () 是创建一个空的元组对象
创建非空元组的字面值表达式:
  t = 200,
  t = (20,)
  t = (1, 2, 3)
  t = 100, 200, 300
注:
  type(x)函数 可以返回对象x的类型

元组错误示例:
  t = (200)  # t 绑定20这个对象，不是元组
  x, y, z = 100, 200, 300  # 序列赋值
  x, y, z = (100, 200, 300)
  x, y, z = [100, 200, 300]
  x, y, z = "ABC"

元组的构造函数tuple
  tuple() 生成一个空的元组　，等同于()
  tuple(iterable)  用可迭代对象生成一个元组

  示例:
  　　t = tuple()
    t = tuple("ABC")
    t = tuple(range(1, 10, 2))


元组的运算:
  + 用于用拼接方式创建一个新的元组
  * 用于生成新的重复的元组

  t = (1,2,3)  + (4, 5, 6)  # t = (1,2,3,4,5,6)
  t += (7,8,9)  # t = (1,2,3,4,5,6,7,8,9)

  t = (1,2) * 3  # t = (1,2,1,2,1,2)
  t *= 4  # t = (1,2,1,2,1,2....)
列表的比较运算:
  < <= > >= == !=  规则与列表的比较规则完全相同

元组的in / not in 运算符
  用于判断元素是否存在于元组中,规则写列表完全相同

索引　index
  用法等于同列表的索引
  元组不支持索引赋值

切片 
  用法与列表的切片用法相同
  元组的切片返回一个新的元组
  元组不能切片赋值


元组的方法:
  T.index(v[,begin[,end]])  返回对应元素的索引下标， begin 为开始索引，end为结束索引，当v不存在时触发ValueError错误
  T.count(x)  返回元组中对应的元素个数




序列小结:
  字符串 str
  列表 list(可变的)
  元组 tuple
  -----以下后面才学----
  字节串　bytes
  字节数组 bytearray(可变的)

序列相关的函数:
  len(x), max(x), min(x), sum(x), any(x), all(x)

  reversed(x)  返回反向顺序的可迭代对象

  示例:
    s = "ABC"
    for ch in s:
        print(ch)  # A B C  # C  B  A

    L = [1, 3, 7, 9]
    L2 = [x **2 for x in reversed(L)]  # [81, 49, 9, 1]


字典 dict
  什么是字典:
    1. 字典是一种可变的容器，可以存储任意类型的数据
    2. 字典中的每个数据都是用'键'(key)进行索引的，而不像序列可以用索引下标进行索引
    3. 字典中的数据没有先后顺序关系,字典的存储是无序的
    4. 字典中的数据以键-值对(key-value)对形式进行映射存储
    5. 字典的键不能重复,且只能用不可变类型作为字典的键

  字典的字面值表示方法:
    以{} 括起来,以冒号(:) 分隔键-值对,各键值对用逗号分隔开

  创建空字典:
    d = {}  # {} 表达式用来创建一个空的字典
  创建非空字典:
    d = {'name': 'weimingze', 'age': 35}
    d = {'a': 100}
    d = {'a': tuple("ABC")}
    d = {'abc': list("ABC")}
    d = {'a': {'b':100, 'c':200}}
    d = {True:'真值', False: '假值', None:'空', 100:'一百'}
    d = {(1970, 1, 1): '计算机元年'}


字典的构造函数 dict
  dict()  创建一个空的字典,等同于{}
  dict(iterable)  用可迭代对象创建一个新的字典
  dict(**kwargs)  用关键字传参形式创建一个新的字典

示例:
  d = dict()
  d = dict([('name', 'baikai'), ('age', 15)])
  d = dict((['name', 'xiaoming'], "AB"))
  d = dict(name='xiaohong', age=15)


字典的操作
  字典的键索引
    用[] 运算符可以获取字典内'键'对应的'值'
  语法:
    v = 字典[键]
  示例:
    d = {'name': 'xiaobai', 'age': 15}
    print(d['name'], '今年', d['age'], '岁')

添加/修改字典的元素
  语法:
    字典[键] = 表达式
  示例:
    d = {}
    d['name'] = 'xiaobai'  #创建新的键'name'同时关联值
    d['age'] = 15  # 创建键并绑定15
    d['age'] = 16  # 修改原来的键'age',重新绑定为16
  说明:
    键不存在,创建键,并绑定值
    键存在,修改键的绑定关系
  
删除字典元素 del语句
  del 字典[键]
  示例:
    d = {1:'一', 'hello': 'world', False:'假值'}
    del d['hello']



字典的 in / not in 运算符
  in用来判断一个键是否存在于字典中,如果存在返回 True,否则返回False
  not in 的返回结果与in 相反

示例:
  d = {'name': '小张', 'age': 20}
  'name' in d  # True
  'age' not in d  # False
  '小张' in d   # False  (只判断键,不判断值)
  20 not in d  # True

练习:
  1.写程序,实现以下要求:
    1) 将如下数据形成一个字典 seasons
      键             值
      1          '春季有1,2,3月'
      2          '夏季有4,5,6月'
      3          '秋季有7,8,9月'
      4          '冬季有10,11,12月'
    2)  让用户输入一个整数代表这个季度,打印这个季度有信息
      如果用户输入的信息不在字典中,则打印"信息不存在"
      ###########################################
1)
  seasons = {
    1: '春季有1,2,3月',
    2: '夏季有4,5,6月',
    3: '秋季有7,8,9月',
    4: '冬季有10,11,12月'
}
print(seasons)
2)
n = int(input("请输入季节: "))
if n in seasons:
    print(n, ' : ', seasons[n])
else:
    print("信息不存在")

#############################################
字典的迭代访问
  字典是可迭代对象,字典只能对'键'进行访问

  示例:
    d= {'aaa': 111, 'bbb': 222, 'ccc': 333}
    for k in d:
        print(k)

可以用于字典的函数:
  len(x)  返回字典的键值对个数
  max(x)  返回字典键的最大值
  min(x)  返回字典键的最小值
  sum(x)  返回字典所有键的和
  any(x)  真值测试,只对键进行测试
  all(x)  真值测试,全部键为真值.结果才为True
示例:
  d = {0: '零', 5:'伍', 8:'捌', 3:'叁'}
  len(d)  # 4
  max(d)  # 8
  min(d)  # 0
  sum(d)  # 16
  any(d)  # True
  all(d)  # False

字典的方法
  方法名       说明
  D.clear()   清空字典
  D.pop(key)  移除键,同时返回此键对应的值
  D.copy()  返回字典D的副本(浅拷贝)
  D.update(D2)  将字典D2合并到D中,如果键相同,则此键的值取D2的值为为新值
  D.get(key, default=None)  返回键key所对应的值,如果没有此键,则返回Default的值

  D.keys()  返回可迭代的dict_keys集合对象
  D.values() 返回可迭代的dict_value集合对象
  D.items()  返回可迭代的dict_item对象

示例:
  d = {1: 'One', 2: "Two"}
  d2 = {2: '二', 3: '三'}
  d3 = d.copy()  # 复制
  d3.pop(1)  # d3 = {2: "Two"}
  d.update(d2)  # d = {1: 'One', 2: '二', 3: '三'}

  d = {1: 'One', 2: '二', 3: '三'}
  for k in d.keys():
      print(k)   # 1 2 3
  for v in d.values():
      print(v)  # 'One' '二' '三'
  for t in d.items():
      print(t)  # (1, 'One') (2, '二') (3, '三')

练习:
  输入任意一段字符串,打印出这个字符串中出现过的字符及出现过的次数:
    如:
      输入: ABCDABCABA
    打印如下:
      A: 4次
      B: 3次
      D: 1次
      C: 2次
    注: 不要求打印的顺序
    ####################################
x=str(input("请输入："))
d={}
for y in x:
    
    if y not in d :
        d[y]=1
    else:
        d[y]=d[y]+1
print(d)

###############################################


字典推导式
  是用可迭代对象生成字典的表达式
  语法:
    {键表达式 : 值表达式 for 变量 in 可迭代对象[if 真值表达式]}
    注: []表示其中的内容可省略
  示例:
    # 生成一个字典,键为数字 1 ~ 9,值为键的平方
    d = {x : x ** 2 for x in range(1, 10)}

字典推导式练习:
  1. 已知有如下字符串列表
    L = ['xiaohong', 'xiaozhang', 'abc']
  生成如下字典:
    d = {'xiaohong': 8, 'xiaozhang': 9, 'abc': 3}
    注: 字典的值为键的长度
# d = {}  # 创建一个空字典
# for s in L:
#     d[s] = len(s)


  2. 已知有如下两个列表:
    nos = [1001, 1002, 1005, 1008]
    names = ['Tom', 'Jerry', 'Spike', 'Tyke']
    用上述两个列表生成如下字典:
    {1001: 'Tom', 1002: 'Jerry', 1005: 'Spike', 1008: 'Tyke'}

d = {nos[index]: names[index]
     for index in range(len(nos))}

print(d)

# {1001: 'Tom', 1002: 'Jerry', 1005: 'Spike', 1008: 'Tyke'}


字典推导式的嵌套等同于列表推导式的嵌套


字典 VS 列表
  1. 都是可变对象
  2. 索引方式,列表用整数索引,字典用键索引
  3. 字典的插入,删除,修改的速度可能会快与列表(重要)
  4. 列表的存储是有序的,字典的存储是无序的

  示例:
   L = [9, 4, 10043, 5, 12, 3......., 123]

   1006 in L  # 



集合 set
  集合是可变的容器
  集合内的数据对象都是唯一的(不能重复多次的)
  集合是无序的存储结构,集合中的数据没有先后关系
  集合内的元素必须是不可变对象
  集合是可迭代对象
  集合是相当于只有键没有值的字典(键则是集合的数据)

创建空的集合:
  set()

创建非空的集合的字面值:
  s = {1, 2, 3}

集合的构造函数:
  set()  创建一个空的集合(不能用{} 来创建空集合)
  set(iterable) 用可迭代对象创建一个新的集合

  示例:
    s = set()
    s = {2,3,5,7}
    s = set("ABC")  # s = {'A', 'B', 'C'}
    s = set("ABCCBA")  # s = {'A', 'B', 'C'}
    s = set({1:"1", 2:'2', 5:'5'}) # s = {1, 2, 5}
    s = set(('ABC', '123', True))
    s = {True, None, "ABC", (1, 2, 3)}

python3 中不可变数据类型
  bool, int, float, complex, str, tuple, frozenset,bytes(后面才学)

  None

可变数据类型
  list, dict, set, bytearray(后面才学)

集合的运算:
  交集&  并集|  补集-  对称补集^  子集<  超集 >

& 用于生成两个集合的交集
  s1 = {1, 2, 3}
  s2 = {2, 3, 4}
  s1 & s2  # {2, 3}

| 生成两个集合的并集
  s1 = {1, 2, 3}
  s2 = {2, 3, 4}
  s1 | s2  # {1, 2, 3, 4}

- 生成两个集合的补集
  s1 = {1, 2, 3}
  s2 = {2, 3, 4}
  s1 - s2  # {1}  # 生成属于s1, 但属于 s2的所元素的集合

^ 生成两个集合的对称补集
  s1 = {1, 2, 3}
  s2 = {2, 3, 4}
  s1 ^ s2  # {1, 4}

> 判断一个集合是另一个集合的超集
< 判断一个集合是别一个集合的子集
  s1 = {1, 2, 3}
  s2 = {2, 3}
  s1 > s2  # True
  s2 < s1  # True

== != 集合相同/不同
  s1 = {1, 2, 3}
  s2 = {3, 2, 1}
  s1 == s2   # True

in / not in 运算
   in 同列表和字典的in运算符规则相同,如果存在于集合中返回 True,否则返回False
示例:
  2 in {1, 2, 3}  # True

用于集合的函数
  len(x)  返回集合的长度
  max(x)  返回集合的最大值元素
  min(x)  返回集合的最小值元素
  sum(x)  返回集合中所有元素的和
  any(x)  真值测试，规则与列表相同
  all(x)  真值测试，规则与列表相同

集合是可迭代对象,可以用于for语句中

练习:
  经理有: 曹操，刘备，孙权
  技术员有: 曹操，孙权，张飞，关羽
  用集合求:
    1. 即是经理也是技术员的有谁?
    2. 是经理，但不是技术人员的都有谁?
    3. 是技术人员，但不是经理的都有谁?
    4. 张飞是经理吗？
    5. 身兼一职的人都有谁?
    6. 经理和技术员共有几个人?
################################

managers = {'曹操', '刘备', '孙权'}
techs = {'曹操', '孙权', '张飞', '关羽'}

print("即是经理也是技术员的有:", managers & techs)
print("是经理，但不是技术人员的都有:", managers - techs)
print("是技术人员，但不是经理的都有:", techs - managers)
if '张飞' in managers:
    print("张飞是经理")
else:
    print("张飞不是经理")

print("身兼一职的人都有", managers ^ techs)
print("经理和技术员共有%d个人" % len(managers | techs))



集合的方法:
  详见:
    >>> help(set)

S.add(e) 在集合中添加一个新的元素e；如果元素已经存在，则不添加
S.remove(e) 从集合中删除一个元素，如果元素不存在于集合中，则会产生一个KeyError错误
S.discard(e)  从集合S中移除一个元素e,在元素e不存在时什么都不做;
S.clear() 清空集合内的所有元素
S.copy()  将集合进行一次浅拷贝
S.pop() 从集合S中删除一个随机元素;如果此集合为空，则引发KeyError异常

集合推导式:
  是用可迭代对象创建集合的表达式 

  语法:
    {表达式 for 变量 in 可迭代对象 [if 真值表达式]}

  [] 部分代表可省略

  示例:
    numbers = [1, 3, 5, 7, 9, 3, 4, 5, 6, 7]
    s = {x ** 2 for x in numbers if x % 2 == 1}
    print(s)



固定集合 frozenset
  固定集合是不可变的，无序的，含有唯一元素的集合

  作用:
    固定集合可以作为字典的键，也可以作为集合的值
  
  固定集合的构造函数 frozenset
    frozenset()  创建一个空的固定集合
    frozenset(iterable) 用可迭代对象创建一个新的固定集合

    示例:
      fz = frozenset()
      fz = frozenset("ABCAB")
      fz = frozenset([1, 2, 3, 4, 5])

固定集合的运算:
  &  交集
  |  并集
  - 补集
  ^ 对称补集
  in / not in运算
  > >= < <= == !=
  (以上运算等同于集合的运算)

固定集合的方法:
  相当于集合的全部方法去掉修改集合的方法


阶段总结:
  数据类型:
    不可变数据类型:
       bool, int, float, complex, str, tuple, frozenset,bytes(后面才学)
    可变的数据类型:
       list, dict, set, bytearray(后面才学)

    值:
      None, False, True, ....
  运算符:
    + - * / // % **
    < <= > >= == !=
    is , is not
    in , not in
    not  and   or
    &  |  ^  ~ << >>
    +(正号)  -(负号)

表达式:
  100
  100 + 200
  max(1,2,3)  # 函数调用也是表达式
  条件表达式  x if x > y else y
  全部的推导式:
      列表，字典，集合推导式(只有三种)

语句:
  表达式 语句:
    print("hello world!")
    '''这是字符串'''
  赋值语句:
    a = 100
    b = c = d = 200
    x, y = 100, 200
    列表[整数表达式] = 表达式
    字典[键] = 表达式
  if 语句
  while语句
  for 语句
  break 语句
  continue语句
  pass 语句
  del 语句
  
  函数:
    len(x),max(x), min(x), sum(x), any(x),all(x)
    构造函数:
      bool(x) int(x),float(x), complex(x),str(x)
      list(x), tuple(x),dict(x),
      set(x), frozenset(x)

    abs(x) round(x), pow(x,y,z=None)
    bin(x), oct(x), hex(x), chr(x), ord(x)
    range(start, stop, step)
    input(x), print(....)


函数 function
  什么是函数
    函数是可以重复执行的语句块，可以重复的调用
  
  作用:
    用于封装语句块，提高代码的重用性
    定义用户级别的函数

def 语句
  语法：
    def 函数名(形参列表):
        语句块（代码块)
  作用:
    用语句块创建一个函数，并用函数名变量绑定这个函数
  语法说明:
    1. 函数名是变量，它用于绑定语句块
    2. 函数有自己的名字空间，在函数外部不可以访问函数内部的变量，在函数内部可以访问函数外部的变量
      (要让函数处理外部的数据需要用参数给函数传入一些数据)
    3. 函数不需要传入参数时，形参列表可以为空
    4. 语句部分不能为空，如果为空需要填充pass语句


函数调用
  函数名(实际调用传递参数)
    注: 实际调用传递参数 以后称为实参

  说明:
   函数调用是一个表达式
   如果函数内部没有return语句，则函数执行完毕后返回None对象



练习:
  写一个函数 myadd,此函数中的参数列表里有两个参数x,y
  此函数的功能是打印x+y的和
      def myadd(...):
         ....

      myadd(100, 200)  # 300
      myadd("ABC", '123')  # ABC123
×××××××××××××××××××××××××××××××××××××××
def myadd(x, y):
    if type(x) is int:
        s = x + y  # 求实参的和
    elif type(x) is str:
        s = y
    print(s)
 

return 语句:
  语法:
    return [表达式]
    注: []代表可以省略其中的内容
  作用:
    用于函数中结束当前函数的执行，返回到调用该函数的地方，同时返回一个对象的引用关系
  return 语句说明:
    1. return 语句后跟表达式可以省略，省略后相当于 return None
    2. 如果函数内没有 return 语句，则函数执行完最后一条语句后返回None(相当于在最后加了一条return None语句)

练习:
  写一个函数myadd2, 实现返回两个数的和:
    如:
      def myadd(a, b):
          .... # 此处自己实现

    #测试代码如下:
      a = int(input("请输入第一个数: "))
      b = int(input("请输入第二个数: "))
      print("您输入的两个数之和是: ", myadd(a, b))
#########################################

def myadd(a, b):
    s = a + b
    return s
a = int(input("请输入第一个数: "))
b = int(input("请输入第二个数: "))
print("您输入的两个数之和是: ", myadd(a, b))


练习:
  1.  写一个函数mymax, 实现返回两个数的最大值:
  如:
    def mymax(a, b):
       ...
    print(mymax(100, 200))  # 200
    print(mymax("ABCD", "ABC"))  # ABCD
####################################
def mymax(a, b):
    if a > b:
        return a
    return b
###################################